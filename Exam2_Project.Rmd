---
title: "QF112 Project"
author: "Andrew Thomas"
date: "2023-04-23"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library("quantmod")

getSymbols("PYPL", src="yahoo", from="2023-01-20", to="2023-04-20")
getSymbols("F", src="yahoo", from="2023-01-20", to="2023-04-20")
getSymbols("MCD", src="yahoo", from="2023-01-20", to="2023-04-20")
getSymbols("SONY", src="yahoo", from="2023-01-20", to="2023-04-20")
getSymbols("BABA", src="yahoo", from="2023-01-20", to="2023-04-20")
getSymbols("ATAT", src="yahoo", from="2023-01-20", to="2023-04-20")

PYPL.P <- c(PYPL$PYPL.Adjusted)
FORD.P <- c(F$F.Adjusted)
MCD.P <- c(MCD$MCD.Adjusted)
SONY.P <- c(SONY$SONY.Adjusted)
BABA.P <- c(BABA$BABA.Adjusted)
ATAT.P <- c(ATAT$ATAT.Adjusted)
```

```{r}
library("MASS")
# 1- Linear Regression
multiple_regression <- function(x, y){
  
  # add a column of 1s to X for the intercept
  x <- cbind(1, as.matrix(x))
  y <- as.matrix(y)
  
  # calculate the coefficients
  betas <- (ginv(t(x) %*% x)) %*% t(x) %*% y
  
  # calculate the residuals
  residuals <- y - x %*% betas
  
  # calculate the standard error of the coefficients
  RSE <- sqrt(sum(residuals^2) / (length(y) - ncol(x)))
  SE_betas <- RSE * sqrt(diag(solve(t(x) %*% x)))
  
  # calculate the t-values and p-values
  t_values <- betas / SE_betas
  p_values <- 2 * pt(abs(t_values), df = length(y) - ncol(x), lower.tail = FALSE)
  
  # calculation for r^2
  RSS = sum(residuals^2)
  TSS = sum((y-mean(y))^2)
  RSQ = 1 - (RSS/TSS)
  
  # return a list of results
  results <- list("Coefficients" = betas, "Std. Errors" = SE_betas, "T-Values" = t_values, "P-Values" = p_values, "R-Squared" = RSQ)
  return(results)
}

multiple_regression(cbind(FORD.P,MCD.P,SONY.P,BABA.P,ATAT.P),PYPL.P)
mult <- lm(PYPL.P ~ FORD.P+MCD.P+SONY.P+BABA.P+ATAT.P)
summary()
```

```{r}
# forward subset selection function
forward_subset <- function(X, y, nvmax) {
  p <- ncol(X)  # number of predictors
  k <- 1  # start with one predictor
  selected <- c()  # initialize selected predictors
  best_rss <- Inf  # initialize best RSS
  all_vars <- colnames(X)  # get names of all predictors

  tss <- sum((y - mean(y))^2)
  
  while (k <= nvmax) {
    remaining <- setdiff(all_vars, selected)  # get remaining predictors
    rss <- rep(-Inf, length(remaining))  # initialize RSS for each remaining predictor

    for (i in seq_along(remaining)) {
      vars <- c(selected, remaining[i])  # predictors to include in model
      model = multiple_regression(X[,vars], y)
      rss = sum(model$Std..Errors^2)
    }

    best_pred <- which.min(rss)  # find the predictor with the lowest RSS
    selected <- c(selected, remaining[best_pred])  # add the predictor to the model
    if (rss[best_pred] < best_rss) {  # if the RSS improves
      best_rss <- rss[best_pred]  # update best RSS
      k <- k + 1  # increase the number of predictors
    } else {  # if the RSS doesn't improve
      break  # exit the loop
    }
  }
  
  rss <- best_rss  # explained sum of squares
  rsq <- 1 - (rss / tss)
  
  # fit the final model using all selected predictors
  fit <- multiple_regression(X[,selected],y)
  rss <- sum(fit$Residuals^2)
  r_squared <- 1 - (rss / tss)
  return(r_squared)
}

forward_subset(cbind(FORD.P,MCD.P,SONY.P,BABA.P,ATAT.P),PYPL.P,5)
```
```{r}
forward_subset <- function(x, y, max_pred) {
  num_predictors <- ncol(x)
  i <- 1 
  chosen_predictors <- c()
  cut_off <- 0
  highest_rsq <- 0
  pred_names <- colnames(x)

  while (i <= max_pred) {
    remaining_predictors <- setdiff(pred_names, chosen_predictors)
    rsq <- rep(0, length(remaining_predictors))

    for (j in 1:length(remaining_predictors)) {
      predictors <- c(chosen_predictors, remaining_predictors[j])
      model <- multiple_regression(x[,predictors], y)
      rsq[j] <- model["R-Squared"]

    }

    best_predictor <- which.max(rsq)
    chosen_predictors <- c(chosen_predictors, remaining_predictors[best_predictor])

    if (rsq[best_predictor] < highest_rsq) {
      cut_off <- i
      i <- i + 1
      best_rsq <- rsq[best_predictor]
    }
  }

  features <- chosen_predictors[1:cut_off]
  best_model <- multiple_regression(x[,features], y)

  return(best_model)
}

forward_subset(cbind(FORD.P,MCD.P,SONY.P,BABA.P,ATAT.P), PYPL.P, 5)
```
```{r}
MSE <- function(){
  
}
```








